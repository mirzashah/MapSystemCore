/*****************************************************************************/
// Filename: Projected2DModel.h
/*****************************************************************************/
// Description: This class is the parent base class for all map projections.
// The goal of classes derived from this class is to project lat/long points
// based on some ellipsoid (see CWorld3DModel) and projecting it to a Cartesian
// coordinate system. Even though obvious, it must be noted that projected
// models create distortions in distance, area, angle, and scale, and one
// must be careful not to think what's on a flat surface is 'real'.
//
// Note that the meridian and parallel of origin are 'state' variables
// for a projection. By default they're set to the equator and prime
// meridian, but projections such as UTM constantly shift them to generate points,
// or they might have to be shifted to give central focus to a particular area
// (Older maps used to use 75 deg W rather than 0 deg to focus on the Americas)
/*****************************************************************************/

#ifndef _PROJECTED_2D_MODEL
#define _PROJECTED_2D_MODEL

#include <CoordinateTypes.h>
#include <MapSystemEnumerations.h>

class CWorld3DModel;

/**
* This class represents all map projections. This is an abstract base class which
* describes the common properties of all map projections.
*/
class CProjected2DModel
{
	friend class CSweepTester;
	public:
/**
* A constructor for this class
*/
		CProjected2DModel();
/**
* A destructor for this class
*/
		virtual ~CProjected2DModel();

/**
* This method will give a distance between two projected points (i.e. it will project two points and use
* Pythagorean theorem to give a distance) WARNING: This method not necessarily true distance, depends
* on projection (actually for most projections, will be WAY off)
* @return Distance between a pair of PROJECTED geographical coordinates in meters.
* @param p1 Geographical point 1
* @param p2 Geographical point 2
* @param worldModel Reference ellipsoid the geographical coordinates are relative to
*/
		double                       DistanceBetweenTwoProjectedCLatLongPoints(const CLatLongPoint& p1, const CLatLongPoint&  p2, const CWorld3DModel& worldModel);

/**
* This method will invert (i.e. give back latitude/longitude coordinates) given Cartesian coordinates
* relative to the ORIGINAL projection. The inverse may not be as accurate as the forward transformation,
* precision will be documented though in subclasses. The origin is defined by the projection, but
* in most cases will be intersection of origin parallel and origin meridian (again not always true).
* @return Geographical coordinates generated by inverse projection of projected Cartesian coordinates.
* @param p Cartesian coordinate of point to be inverted
* @param worldModel Reference ellipsoid the forward projection was generated from
*/
		virtual CLatLongPoint         InverseProjectPoint(const CXYPoint& p, const CWorld3DModel& worldModel) = 0;

/**
* This method will test a point before it projected to ensure it is plottable on the map. Projections which do not
* override this method assume every valid lat/long point is valid.
* @param p Geographical coordinate to test
* @param worldModel Reference ellipsoid the geographical coordinate is relative to
* @return boolean true if point is plottable, false otherwise
*/
		virtual bool                  IsPointPlottable(const CLatLongPoint& p, const CWorld3DModel& worldModel);

/**
* This method will project a geographical coordinates point onto a flat Cartesian grid.
* The origin of the Cartesian grid is defined by the
* projection, but in most cases will be interesection of origin parallel and origin meridian (again not always true).
* @return Geographical coordinates generated by inverse projection of projected Cartesian coordinates.
* @param p Geographical coordinate of point to be projected
* @param worldModel Reference ellipsoid the geographical coordinate is relative to.
*/
		virtual CXYPoint              ProjectPoint(const CLatLongPoint& p, const CWorld3DModel& worldModel) = 0;

/**
* This method will give the <I>scale factor</I> of a geographical point on the current projection. What
* scale factor refers to is a ratio between <I>true scale</I> and <I>ideal scale</I>. The
* true scale is always = 1.0. The true scale is what the actual scale is for that point on the map
* at the point. Almost all projecions have varying scale throughout the map, and true scale is only
* along a certain line. The scale ratio indicates how exaggerated the scale is at a given point, if
* it's less than one, it means that the scale is smaller and things look closer than they are, and if
* it's bigger, things appear stretched. On a Mercator projection, scale factor is true, or = 1.0, along
* the equator, but as you go north or south, it gets significantly bigger. That is why Greenland looks
* huge on a Mercator projection.
* @return Scale factor at given geographical coordinate.
* @param p Geographical coordinate of point to find scale factor for.
* @param worldModel Reference ellipsoid the geographical coordinate is relative to.
*/
		virtual double               ScaleFactorForPoint(const CLatLongPoint& p, const CWorld3DModel& worldModel) = 0;

/**
* This method sets the meridian of origin (i.e. central meridian) to be used by the projection. This
* is also known in projection equations as lambda0 (Greek letter lambda, subscript '0'). By default
* set at 0 degrees (Prime Meridian), but can be changed depending on projection to manipulate "view"
* of projection, and relative origin.
* @param originMeridian The value the origin meridian is to be set to.
*/
		void                 SetOriginMeridian(double originMeridian);

/**
* This method sets the parallel of origin (i.e. central parallel) to be used by the projection. This
* is also known in projection equations as phi0 (Greek letter phi, subscript '0'). By default
* set at 0 degrees (the Equator), but can be changed depending on projection to manipulate "view"
* of projection, and relative origin.
* @param originParallel The value the origin parallel is to be set to.
*/
		void                  SetOriginParallel(double originParallel);

/**
* This method can determine the type of projection we're using run-time dynamic dispatch.
* @return A PROJECTED_MODEL_TYPE indicating which subclass the current instance belongs
* to.
*/
		virtual PROJECTED_MODEL_TYPE WhichProjectionAmI() const = 0;

	protected:
/**
* Gives back the current meridian of origin
* @return Return the current meridian of origin in degrees
*/
		double               OriginMeridian() const;

/**
* Gives back the current parallel of origin
* @return Return the current parallel of origin in degrees
*/
		double               OriginParallel() const;

	private:

/**
* Performs Pythagorean theorem to calculate distance between two Cartesian points
* @return Return distance between two XY points using Pythagorean theorem
*/
		double               DistanceBetweenTwoCXYPoints(const CXYPoint& p1, const CXYPoint& p2) const;

	private:

/** The current meridian of origin */
		double               _originMeridian;

/** The current parallel of origin */
		double               _originParallel;
};

#endif
